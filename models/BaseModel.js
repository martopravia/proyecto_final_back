import { Model } from "sequelize";
import bcrypt from "bcryptjs";

export class BaseModel extends Model {
  static sanitizeData(data) {
    const attributes = this.getAttributes();
    const allowedKeys = Object.entries(attributes)
      .filter(([key, attr]) => {
        return !attr._autoGenerated && !attr.primaryKey;
      })
      .map(([key]) => key);

    const result = {};

    for (let key of allowedKeys) {
      if (!(key in data) || data[key] == undefined) continue;
      let value = data[key];

      const typeKey = attributes[key].type?.key;

      if (typeKey && typeCasters[typeKey]) {
        value = typeCasters[typeKey](value, key);
      }

      result[key] = value;
    }
    return result;
  }

  static passwordAttribute = "password";
  static async encryptPassword(entity, options) {
    if (entity.changed(this.passwordAttribute)) {
      entity[this.passwordAttribute] = await bcrypt.hash(
        entity[this.passwordAttribute],
        parseInt(process.env.HASH_COST_FACTOR),
      );
    }
  }
  static async verifyPassword(inputPassword, storedHash) {
    return await bcrypt.compare(inputPassword, storedHash);
  }
}

const typeCasters = {
  STRING: (value, key) => {
    if (typeof value === "string") return value;
    if (typeof value === "object") throw new Error(`Invalid string at ${key}`);
    return String(value);
  },
  TEXT: (value, key) => {
    if (typeof value === "string") return value;
    if (typeof value === "object") throw new Error(`Invalid string at ${key}`);
    return String(value);
  },
  INTEGER: (value, key) => {
    if (isNaN(parseInt(value))) throw new Error(`Invalid integer at ${key}`);
    return value;
  },
  BIGINT: (value, key) => {
    if (isNaN(parseInt(value))) throw new Error(`Invalid bigInt at ${key}`);
    return value;
  },
  FLOAT: (value, key) => {
    if (isNaN(parseFloat(value))) throw new Error(`Invalid float at ${key}`);
    return value;
  },
  DOUBLE: (value, key) => {
    if (isNaN(parseFloat(value))) throw new Error(`Invalid double at ${key}`);
    return value;
  },
  DECIMAL: (value, key) => {
    if (isNaN(parseFloat(value))) throw new Error(`Invalid decimal at ${key}`);
    return value;
  },
  BOOLEAN: (value, key) => {
    if (value === "true" || value === true) return true;
    if (value === "false" || value === false) return false;
    throw new Error(`Invalid boolean at ${key}`);
  },
  DATE: (value, key) => {
    if (value instanceof Date && !isNaN(value.getTime())) {
      return value;
    }
    const d = new Date(value);
    if (isNaN(d.getTime())) throw new Error(`Invalid date at ${key}`);
    return d;
  },
  JSON: (value, key) => {
    if (typeof value === "string") {
      try {
        const parsed = JSON.parse(value);
        if (typeof parsed === "object" && parsed !== null) {
          return parsed;
        }
        throw new Error(`Parsed value is not a JSON object or array at ${key}`);
      } catch {
        throw new Error(`Invalid JSON string at ${key}`);
      }
    }

    if (typeof value === "object" && value !== null) {
      return value;
    }

    throw new Error("Invalid JSON input");
  },
};
